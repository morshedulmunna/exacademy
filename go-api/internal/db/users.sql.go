// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: users.sql

package db

import (
	"context"
	"database/sql"

	"github.com/google/uuid"
)

const getTopUsers = `-- name: GetTopUsers :many
SELECT 
    u.id,
    u.username,
    u.first_name,
    u.last_name,
    u.full_name,
    u.profile_pic,
    u.about,
    u.created_at,
    -- Activity metrics
    COUNT(DISTINCT cp.id) as post_count,
    COUNT(DISTINCT pr.id) as reaction_count,
    COUNT(DISTINCT cm.community_id) as community_count,
    -- Engagement score (weighted calculation)
    (
        COUNT(DISTINCT cp.id) * 10 + 
        COUNT(DISTINCT pr.id) * 2 + 
        COUNT(DISTINCT cm.community_id) * 5
    ) as engagement_score
FROM users u
LEFT JOIN community_posts cp ON u.id = cp.user_id
LEFT JOIN post_reactions pr ON u.id = pr.user_id
LEFT JOIN community_members cm ON u.id = cm.user_id AND cm.status = 'active'
WHERE u.is_active = true 
    AND u.created_at >= NOW() - INTERVAL '30 days'
GROUP BY u.id, u.username, u.first_name, u.last_name, u.full_name, u.profile_pic, u.about, u.created_at
HAVING COUNT(DISTINCT cp.id) > 0 OR COUNT(DISTINCT pr.id) > 0
ORDER BY engagement_score DESC, u.created_at DESC
LIMIT $1
`

type GetTopUsersRow struct {
	ID              uuid.UUID      `db:"id" json:"id"`
	Username        string         `db:"username" json:"username"`
	FirstName       sql.NullString `db:"first_name" json:"first_name"`
	LastName        sql.NullString `db:"last_name" json:"last_name"`
	FullName        sql.NullString `db:"full_name" json:"full_name"`
	ProfilePic      sql.NullString `db:"profile_pic" json:"profile_pic"`
	About           sql.NullString `db:"about" json:"about"`
	CreatedAt       sql.NullTime   `db:"created_at" json:"created_at"`
	PostCount       int64          `db:"post_count" json:"post_count"`
	ReactionCount   int64          `db:"reaction_count" json:"reaction_count"`
	CommunityCount  int64          `db:"community_count" json:"community_count"`
	EngagementScore int32          `db:"engagement_score" json:"engagement_score"`
}

func (q *Queries) GetTopUsers(ctx context.Context, db DBTX, limit int32) ([]GetTopUsersRow, error) {
	rows, err := db.QueryContext(ctx, getTopUsers, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTopUsersRow
	for rows.Next() {
		var i GetTopUsersRow
		if err := rows.Scan(
			&i.ID,
			&i.Username,
			&i.FirstName,
			&i.LastName,
			&i.FullName,
			&i.ProfilePic,
			&i.About,
			&i.CreatedAt,
			&i.PostCount,
			&i.ReactionCount,
			&i.CommunityCount,
			&i.EngagementScore,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserByEmail = `-- name: GetUserByEmail :one
SELECT 
    u.id,
    u.email,
    u.username,
    u.password,
    u.first_name,
    u.last_name,
    u.full_name,
    u.is_email_verified,
    u.is_active,
    u.has_access,
    u.last_login_at,
    u.last_failed_login_at,
    u.failed_login_attempts,
    u.created_at,
    r.name as role_name,
    r.description as role_description
FROM users u
LEFT JOIN roles r ON u.roles_id = r.id
WHERE u.email = $1 AND u.is_active = true
LIMIT 1
`

type GetUserByEmailRow struct {
	ID                  uuid.UUID      `db:"id" json:"id"`
	Email               string         `db:"email" json:"email"`
	Username            string         `db:"username" json:"username"`
	Password            sql.NullString `db:"password" json:"password"`
	FirstName           sql.NullString `db:"first_name" json:"first_name"`
	LastName            sql.NullString `db:"last_name" json:"last_name"`
	FullName            sql.NullString `db:"full_name" json:"full_name"`
	IsEmailVerified     sql.NullBool   `db:"is_email_verified" json:"is_email_verified"`
	IsActive            sql.NullBool   `db:"is_active" json:"is_active"`
	HasAccess           sql.NullBool   `db:"has_access" json:"has_access"`
	LastLoginAt         sql.NullTime   `db:"last_login_at" json:"last_login_at"`
	LastFailedLoginAt   sql.NullTime   `db:"last_failed_login_at" json:"last_failed_login_at"`
	FailedLoginAttempts sql.NullInt32  `db:"failed_login_attempts" json:"failed_login_attempts"`
	CreatedAt           sql.NullTime   `db:"created_at" json:"created_at"`
	RoleName            sql.NullString `db:"role_name" json:"role_name"`
	RoleDescription     sql.NullString `db:"role_description" json:"role_description"`
}

func (q *Queries) GetUserByEmail(ctx context.Context, db DBTX, email string) (GetUserByEmailRow, error) {
	row := db.QueryRowContext(ctx, getUserByEmail, email)
	var i GetUserByEmailRow
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.Username,
		&i.Password,
		&i.FirstName,
		&i.LastName,
		&i.FullName,
		&i.IsEmailVerified,
		&i.IsActive,
		&i.HasAccess,
		&i.LastLoginAt,
		&i.LastFailedLoginAt,
		&i.FailedLoginAttempts,
		&i.CreatedAt,
		&i.RoleName,
		&i.RoleDescription,
	)
	return i, err
}

const getUserByID = `-- name: GetUserByID :one
SELECT 
    u.id,
    u.email,
    u.username,
    u.first_name,
    u.last_name,
    u.full_name,
    u.profile_pic,
    u.about,
    u.phone,
    u.provider,
    u.provider_id,
    u.is_email_verified,
    u.is_active,
    u.has_access,
    u.last_login_at,
    u.last_failed_login_at,
    u.failed_login_attempts,
    u.password_changed_at,
    u.two_factor_enabled,
    u.created_at,
    u.updated_at,
    -- Role information
    r.name as role_name,
    r.description as role_description,
    -- Profile completion percentage
    CASE 
        WHEN u.profile_pic IS NOT NULL THEN 1 
        ELSE 0 
    END + 
    CASE 
        WHEN u.about IS NOT NULL THEN 1 
        ELSE 0 
    END + 
    CASE 
        WHEN u.phone IS NOT NULL THEN 1 
        ELSE 0 
    END + 
    CASE 
        WHEN u.first_name IS NOT NULL THEN 1 
        ELSE 0 
    END as profile_completion
FROM users u
LEFT JOIN roles r ON u.roles_id = r.id
WHERE u.id = $1 AND u.is_active = true
LIMIT 1
`

type GetUserByIDRow struct {
	ID                  uuid.UUID      `db:"id" json:"id"`
	Email               string         `db:"email" json:"email"`
	Username            string         `db:"username" json:"username"`
	FirstName           sql.NullString `db:"first_name" json:"first_name"`
	LastName            sql.NullString `db:"last_name" json:"last_name"`
	FullName            sql.NullString `db:"full_name" json:"full_name"`
	ProfilePic          sql.NullString `db:"profile_pic" json:"profile_pic"`
	About               sql.NullString `db:"about" json:"about"`
	Phone               sql.NullString `db:"phone" json:"phone"`
	Provider            string         `db:"provider" json:"provider"`
	ProviderID          string         `db:"provider_id" json:"provider_id"`
	IsEmailVerified     sql.NullBool   `db:"is_email_verified" json:"is_email_verified"`
	IsActive            sql.NullBool   `db:"is_active" json:"is_active"`
	HasAccess           sql.NullBool   `db:"has_access" json:"has_access"`
	LastLoginAt         sql.NullTime   `db:"last_login_at" json:"last_login_at"`
	LastFailedLoginAt   sql.NullTime   `db:"last_failed_login_at" json:"last_failed_login_at"`
	FailedLoginAttempts sql.NullInt32  `db:"failed_login_attempts" json:"failed_login_attempts"`
	PasswordChangedAt   sql.NullTime   `db:"password_changed_at" json:"password_changed_at"`
	TwoFactorEnabled    sql.NullBool   `db:"two_factor_enabled" json:"two_factor_enabled"`
	CreatedAt           sql.NullTime   `db:"created_at" json:"created_at"`
	UpdatedAt           sql.NullTime   `db:"updated_at" json:"updated_at"`
	RoleName            sql.NullString `db:"role_name" json:"role_name"`
	RoleDescription     sql.NullString `db:"role_description" json:"role_description"`
	ProfileCompletion   int32          `db:"profile_completion" json:"profile_completion"`
}

func (q *Queries) GetUserByID(ctx context.Context, db DBTX, id uuid.UUID) (GetUserByIDRow, error) {
	row := db.QueryRowContext(ctx, getUserByID, id)
	var i GetUserByIDRow
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.Username,
		&i.FirstName,
		&i.LastName,
		&i.FullName,
		&i.ProfilePic,
		&i.About,
		&i.Phone,
		&i.Provider,
		&i.ProviderID,
		&i.IsEmailVerified,
		&i.IsActive,
		&i.HasAccess,
		&i.LastLoginAt,
		&i.LastFailedLoginAt,
		&i.FailedLoginAttempts,
		&i.PasswordChangedAt,
		&i.TwoFactorEnabled,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.RoleName,
		&i.RoleDescription,
		&i.ProfileCompletion,
	)
	return i, err
}

const getUserByUsername = `-- name: GetUserByUsername :one
SELECT 
    u.id,
    u.email,
    u.username,
    u.first_name,
    u.last_name,
    u.full_name,
    u.profile_pic,
    u.about,
    u.is_email_verified,
    u.is_active,
    u.has_access,
    u.created_at,
    r.name as role_name
FROM users u
LEFT JOIN roles r ON u.roles_id = r.id
WHERE u.username = $1 AND u.is_active = true
LIMIT 1
`

type GetUserByUsernameRow struct {
	ID              uuid.UUID      `db:"id" json:"id"`
	Email           string         `db:"email" json:"email"`
	Username        string         `db:"username" json:"username"`
	FirstName       sql.NullString `db:"first_name" json:"first_name"`
	LastName        sql.NullString `db:"last_name" json:"last_name"`
	FullName        sql.NullString `db:"full_name" json:"full_name"`
	ProfilePic      sql.NullString `db:"profile_pic" json:"profile_pic"`
	About           sql.NullString `db:"about" json:"about"`
	IsEmailVerified sql.NullBool   `db:"is_email_verified" json:"is_email_verified"`
	IsActive        sql.NullBool   `db:"is_active" json:"is_active"`
	HasAccess       sql.NullBool   `db:"has_access" json:"has_access"`
	CreatedAt       sql.NullTime   `db:"created_at" json:"created_at"`
	RoleName        sql.NullString `db:"role_name" json:"role_name"`
}

func (q *Queries) GetUserByUsername(ctx context.Context, db DBTX, username string) (GetUserByUsernameRow, error) {
	row := db.QueryRowContext(ctx, getUserByUsername, username)
	var i GetUserByUsernameRow
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.Username,
		&i.FirstName,
		&i.LastName,
		&i.FullName,
		&i.ProfilePic,
		&i.About,
		&i.IsEmailVerified,
		&i.IsActive,
		&i.HasAccess,
		&i.CreatedAt,
		&i.RoleName,
	)
	return i, err
}

const getUserRecommendations = `-- name: GetUserRecommendations :many
SELECT 
    u.id,
    u.username,
    u.first_name,
    u.last_name,
    u.full_name,
    u.profile_pic,
    u.about,
    u.created_at,
    -- Recommendation score based on common interests
    COUNT(DISTINCT cm.community_id) as common_communities,
    -- Calculate similarity score
    (
        COUNT(DISTINCT cm.community_id) * 3
    ) as similarity_score
FROM users u
INNER JOIN community_members cm ON u.id = cm.user_id
WHERE u.is_active = true 
    AND u.id != $1  -- Exclude the requesting user
    AND cm.community_id IN (
        SELECT community_id 
        FROM community_members 
        WHERE user_id = $1 AND status = 'active'
    )
GROUP BY u.id, u.username, u.first_name, u.last_name, u.full_name, u.profile_pic, u.about, u.created_at
ORDER BY similarity_score DESC, u.created_at DESC
LIMIT $2
`

type GetUserRecommendationsParams struct {
	ID    uuid.UUID `db:"id" json:"id"`
	Limit int32     `db:"limit" json:"limit"`
}

type GetUserRecommendationsRow struct {
	ID                uuid.UUID      `db:"id" json:"id"`
	Username          string         `db:"username" json:"username"`
	FirstName         sql.NullString `db:"first_name" json:"first_name"`
	LastName          sql.NullString `db:"last_name" json:"last_name"`
	FullName          sql.NullString `db:"full_name" json:"full_name"`
	ProfilePic        sql.NullString `db:"profile_pic" json:"profile_pic"`
	About             sql.NullString `db:"about" json:"about"`
	CreatedAt         sql.NullTime   `db:"created_at" json:"created_at"`
	CommonCommunities int64          `db:"common_communities" json:"common_communities"`
	SimilarityScore   int32          `db:"similarity_score" json:"similarity_score"`
}

func (q *Queries) GetUserRecommendations(ctx context.Context, db DBTX, arg GetUserRecommendationsParams) ([]GetUserRecommendationsRow, error) {
	rows, err := db.QueryContext(ctx, getUserRecommendations, arg.ID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetUserRecommendationsRow
	for rows.Next() {
		var i GetUserRecommendationsRow
		if err := rows.Scan(
			&i.ID,
			&i.Username,
			&i.FirstName,
			&i.LastName,
			&i.FullName,
			&i.ProfilePic,
			&i.About,
			&i.CreatedAt,
			&i.CommonCommunities,
			&i.SimilarityScore,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserStats = `-- name: GetUserStats :one
SELECT 
    u.id,
    u.username,
    u.first_name,
    u.last_name,
    u.full_name,
    u.profile_pic,
    u.created_at,
    -- Community statistics
    COUNT(DISTINCT cm.community_id) as total_communities,
    COUNT(DISTINCT CASE WHEN cm.status = 'active' THEN cm.community_id END) as active_communities,
    -- Content statistics
    COUNT(DISTINCT cp.id) as total_posts,
    COUNT(DISTINCT pr.id) as total_reactions_given,
    COUNT(DISTINCT pr2.id) as total_reactions_received,
    -- Activity statistics
    u.last_login_at,
    MAX(cp.created_at) as last_post_date,
    -- Engagement metrics
    CASE 
        WHEN COUNT(DISTINCT cp.id) > 0 
        THEN ROUND(COUNT(DISTINCT pr2.id)::numeric / COUNT(DISTINCT cp.id), 2)
        ELSE 0 
    END as avg_reactions_per_post
FROM users u
LEFT JOIN community_members cm ON u.id = cm.user_id
LEFT JOIN community_posts cp ON u.id = cp.user_id
LEFT JOIN post_reactions pr ON u.id = pr.user_id
LEFT JOIN post_reactions pr2 ON cp.id = pr2.post_id
WHERE u.id = $1 AND u.is_active = true
GROUP BY u.id, u.username, u.first_name, u.last_name, u.full_name, u.profile_pic, u.created_at, u.last_login_at
`

type GetUserStatsRow struct {
	ID                     uuid.UUID      `db:"id" json:"id"`
	Username               string         `db:"username" json:"username"`
	FirstName              sql.NullString `db:"first_name" json:"first_name"`
	LastName               sql.NullString `db:"last_name" json:"last_name"`
	FullName               sql.NullString `db:"full_name" json:"full_name"`
	ProfilePic             sql.NullString `db:"profile_pic" json:"profile_pic"`
	CreatedAt              sql.NullTime   `db:"created_at" json:"created_at"`
	TotalCommunities       int64          `db:"total_communities" json:"total_communities"`
	ActiveCommunities      int64          `db:"active_communities" json:"active_communities"`
	TotalPosts             int64          `db:"total_posts" json:"total_posts"`
	TotalReactionsGiven    int64          `db:"total_reactions_given" json:"total_reactions_given"`
	TotalReactionsReceived int64          `db:"total_reactions_received" json:"total_reactions_received"`
	LastLoginAt            sql.NullTime   `db:"last_login_at" json:"last_login_at"`
	LastPostDate           interface{}    `db:"last_post_date" json:"last_post_date"`
	AvgReactionsPerPost    int32          `db:"avg_reactions_per_post" json:"avg_reactions_per_post"`
}

func (q *Queries) GetUserStats(ctx context.Context, db DBTX, id uuid.UUID) (GetUserStatsRow, error) {
	row := db.QueryRowContext(ctx, getUserStats, id)
	var i GetUserStatsRow
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.FirstName,
		&i.LastName,
		&i.FullName,
		&i.ProfilePic,
		&i.CreatedAt,
		&i.TotalCommunities,
		&i.ActiveCommunities,
		&i.TotalPosts,
		&i.TotalReactionsGiven,
		&i.TotalReactionsReceived,
		&i.LastLoginAt,
		&i.LastPostDate,
		&i.AvgReactionsPerPost,
	)
	return i, err
}

const getUsersByActivityRange = `-- name: GetUsersByActivityRange :many
SELECT 
    u.id,
    u.username,
    u.first_name,
    u.last_name,
    u.full_name,
    u.profile_pic,
    u.created_at,
    u.last_login_at,
    COUNT(DISTINCT cp.id) as post_count,
    COUNT(DISTINCT pr.id) as reaction_count,
    COUNT(DISTINCT cm.community_id) as community_count,
    -- Activity level classification
    CASE 
        WHEN COUNT(DISTINCT cp.id) >= 20 AND COUNT(DISTINCT pr.id) >= 50 THEN 'Very Active'
        WHEN COUNT(DISTINCT cp.id) >= 10 AND COUNT(DISTINCT pr.id) >= 25 THEN 'Active'
        WHEN COUNT(DISTINCT cp.id) >= 5 AND COUNT(DISTINCT pr.id) >= 10 THEN 'Moderate'
        WHEN COUNT(DISTINCT cp.id) >= 1 OR COUNT(DISTINCT pr.id) >= 1 THEN 'Occasional'
        ELSE 'Inactive'
    END as activity_level
FROM users u
LEFT JOIN community_posts cp ON u.id = cp.user_id AND cp.created_at >= $1
LEFT JOIN post_reactions pr ON u.id = pr.user_id AND pr.created_at >= $1
LEFT JOIN community_members cm ON u.id = cm.user_id AND cm.joined_at >= $1
WHERE u.is_active = true
GROUP BY u.id, u.username, u.first_name, u.last_name, u.full_name, u.profile_pic, u.created_at, u.last_login_at
ORDER BY 
    CASE WHEN $2 = 'posts' THEN COUNT(DISTINCT cp.id) END DESC,
    CASE WHEN $2 = 'reactions' THEN COUNT(DISTINCT pr.id) END DESC,
    CASE WHEN $2 = 'communities' THEN COUNT(DISTINCT cm.community_id) END DESC,
    CASE WHEN $2 = 'recent' THEN u.last_login_at END DESC
LIMIT $3 OFFSET $4
`

type GetUsersByActivityRangeParams struct {
	CreatedAt sql.NullTime `db:"created_at" json:"created_at"`
	Column2   interface{}  `db:"column_2" json:"column_2"`
	Limit     int32        `db:"limit" json:"limit"`
	Offset    int32        `db:"offset" json:"offset"`
}

type GetUsersByActivityRangeRow struct {
	ID             uuid.UUID      `db:"id" json:"id"`
	Username       string         `db:"username" json:"username"`
	FirstName      sql.NullString `db:"first_name" json:"first_name"`
	LastName       sql.NullString `db:"last_name" json:"last_name"`
	FullName       sql.NullString `db:"full_name" json:"full_name"`
	ProfilePic     sql.NullString `db:"profile_pic" json:"profile_pic"`
	CreatedAt      sql.NullTime   `db:"created_at" json:"created_at"`
	LastLoginAt    sql.NullTime   `db:"last_login_at" json:"last_login_at"`
	PostCount      int64          `db:"post_count" json:"post_count"`
	ReactionCount  int64          `db:"reaction_count" json:"reaction_count"`
	CommunityCount int64          `db:"community_count" json:"community_count"`
	ActivityLevel  string         `db:"activity_level" json:"activity_level"`
}

func (q *Queries) GetUsersByActivityRange(ctx context.Context, db DBTX, arg GetUsersByActivityRangeParams) ([]GetUsersByActivityRangeRow, error) {
	rows, err := db.QueryContext(ctx, getUsersByActivityRange,
		arg.CreatedAt,
		arg.Column2,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetUsersByActivityRangeRow
	for rows.Next() {
		var i GetUsersByActivityRangeRow
		if err := rows.Scan(
			&i.ID,
			&i.Username,
			&i.FirstName,
			&i.LastName,
			&i.FullName,
			&i.ProfilePic,
			&i.CreatedAt,
			&i.LastLoginAt,
			&i.PostCount,
			&i.ReactionCount,
			&i.CommunityCount,
			&i.ActivityLevel,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUsersByCommunity = `-- name: GetUsersByCommunity :many
SELECT 
    u.id,
    u.username,
    u.first_name,
    u.last_name,
    u.full_name,
    u.profile_pic,
    u.about,
    u.is_email_verified,
    u.created_at,
    cm.joined_at,
    cm.status as membership_status,
    cm.is_paid,
    cm.is_subscribe,
    -- User activity in this community
    COUNT(DISTINCT cp.id) as post_count,
    COUNT(DISTINCT pr.id) as reaction_count,
    MAX(cp.created_at) as last_post_date
FROM users u
INNER JOIN community_members cm ON u.id = cm.user_id
LEFT JOIN community_posts cp ON u.id = cp.user_id AND cp.community_id = cm.community_id
LEFT JOIN post_reactions pr ON u.id = pr.user_id AND pr.post_id = cp.id
WHERE cm.community_id = $1 AND u.is_active = true
GROUP BY u.id, cm.joined_at, cm.status, cm.is_paid, cm.is_subscribe
ORDER BY 
    CASE WHEN $2 = 'recent' THEN cm.joined_at END DESC,
    CASE WHEN $2 = 'active' THEN COUNT(DISTINCT cp.id) END DESC,
    CASE WHEN $2 = 'name' THEN u.first_name END ASC,
    CASE WHEN $2 = 'name' THEN u.last_name END ASC
LIMIT $3 OFFSET $4
`

type GetUsersByCommunityParams struct {
	CommunityID uuid.UUID   `db:"community_id" json:"community_id"`
	Column2     interface{} `db:"column_2" json:"column_2"`
	Limit       int32       `db:"limit" json:"limit"`
	Offset      int32       `db:"offset" json:"offset"`
}

type GetUsersByCommunityRow struct {
	ID               uuid.UUID      `db:"id" json:"id"`
	Username         string         `db:"username" json:"username"`
	FirstName        sql.NullString `db:"first_name" json:"first_name"`
	LastName         sql.NullString `db:"last_name" json:"last_name"`
	FullName         sql.NullString `db:"full_name" json:"full_name"`
	ProfilePic       sql.NullString `db:"profile_pic" json:"profile_pic"`
	About            sql.NullString `db:"about" json:"about"`
	IsEmailVerified  sql.NullBool   `db:"is_email_verified" json:"is_email_verified"`
	CreatedAt        sql.NullTime   `db:"created_at" json:"created_at"`
	JoinedAt         sql.NullTime   `db:"joined_at" json:"joined_at"`
	MembershipStatus sql.NullString `db:"membership_status" json:"membership_status"`
	IsPaid           sql.NullBool   `db:"is_paid" json:"is_paid"`
	IsSubscribe      sql.NullBool   `db:"is_subscribe" json:"is_subscribe"`
	PostCount        int64          `db:"post_count" json:"post_count"`
	ReactionCount    int64          `db:"reaction_count" json:"reaction_count"`
	LastPostDate     interface{}    `db:"last_post_date" json:"last_post_date"`
}

func (q *Queries) GetUsersByCommunity(ctx context.Context, db DBTX, arg GetUsersByCommunityParams) ([]GetUsersByCommunityRow, error) {
	rows, err := db.QueryContext(ctx, getUsersByCommunity,
		arg.CommunityID,
		arg.Column2,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetUsersByCommunityRow
	for rows.Next() {
		var i GetUsersByCommunityRow
		if err := rows.Scan(
			&i.ID,
			&i.Username,
			&i.FirstName,
			&i.LastName,
			&i.FullName,
			&i.ProfilePic,
			&i.About,
			&i.IsEmailVerified,
			&i.CreatedAt,
			&i.JoinedAt,
			&i.MembershipStatus,
			&i.IsPaid,
			&i.IsSubscribe,
			&i.PostCount,
			&i.ReactionCount,
			&i.LastPostDate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUsersByRole = `-- name: GetUsersByRole :many
SELECT 
    u.id,
    u.username,
    u.first_name,
    u.last_name,
    u.full_name,
    u.profile_pic,
    u.email,
    u.is_email_verified,
    u.is_active,
    u.has_access,
    u.created_at,
    u.last_login_at
FROM users u
INNER JOIN roles r ON u.roles_id = r.id
WHERE r.name = $1 AND u.is_active = true
ORDER BY u.created_at DESC
LIMIT $2 OFFSET $3
`

type GetUsersByRoleParams struct {
	Name   string `db:"name" json:"name"`
	Limit  int32  `db:"limit" json:"limit"`
	Offset int32  `db:"offset" json:"offset"`
}

type GetUsersByRoleRow struct {
	ID              uuid.UUID      `db:"id" json:"id"`
	Username        string         `db:"username" json:"username"`
	FirstName       sql.NullString `db:"first_name" json:"first_name"`
	LastName        sql.NullString `db:"last_name" json:"last_name"`
	FullName        sql.NullString `db:"full_name" json:"full_name"`
	ProfilePic      sql.NullString `db:"profile_pic" json:"profile_pic"`
	Email           string         `db:"email" json:"email"`
	IsEmailVerified sql.NullBool   `db:"is_email_verified" json:"is_email_verified"`
	IsActive        sql.NullBool   `db:"is_active" json:"is_active"`
	HasAccess       sql.NullBool   `db:"has_access" json:"has_access"`
	CreatedAt       sql.NullTime   `db:"created_at" json:"created_at"`
	LastLoginAt     sql.NullTime   `db:"last_login_at" json:"last_login_at"`
}

func (q *Queries) GetUsersByRole(ctx context.Context, db DBTX, arg GetUsersByRoleParams) ([]GetUsersByRoleRow, error) {
	rows, err := db.QueryContext(ctx, getUsersByRole, arg.Name, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetUsersByRoleRow
	for rows.Next() {
		var i GetUsersByRoleRow
		if err := rows.Scan(
			&i.ID,
			&i.Username,
			&i.FirstName,
			&i.LastName,
			&i.FullName,
			&i.ProfilePic,
			&i.Email,
			&i.IsEmailVerified,
			&i.IsActive,
			&i.HasAccess,
			&i.CreatedAt,
			&i.LastLoginAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUsers = `-- name: ListUsers :many
SELECT 
    u.id,
    u.email,
    u.username,
    u.first_name,
    u.last_name,
    u.full_name,
    u.profile_pic,
    u.about,
    u.is_email_verified,
    u.is_active,
    u.has_access,
    u.last_login_at,
    u.created_at,
    r.name as role_name,
    -- Community membership count
    COUNT(DISTINCT cm.community_id) as community_count,
    -- Post count
    COUNT(DISTINCT cp.id) as post_count,
    -- Last activity
    GREATEST(u.last_login_at, MAX(cp.created_at)) as last_activity
FROM users u
LEFT JOIN roles r ON u.roles_id = r.id
LEFT JOIN community_members cm ON u.id = cm.user_id AND cm.status = 'active'
LEFT JOIN community_posts cp ON u.id = cp.user_id
WHERE u.is_active = true
GROUP BY u.id, r.name
ORDER BY 
    CASE WHEN $3 = 'recent' THEN u.created_at END DESC,
    CASE WHEN $3 = 'active' THEN GREATEST(u.last_login_at, MAX(cp.created_at)) END DESC,
    CASE WHEN $3 = 'name' THEN u.first_name END ASC,
    CASE WHEN $3 = 'name' THEN u.last_name END ASC
LIMIT $1 OFFSET $2
`

type ListUsersParams struct {
	Limit   int32       `db:"limit" json:"limit"`
	Offset  int32       `db:"offset" json:"offset"`
	Column3 interface{} `db:"column_3" json:"column_3"`
}

type ListUsersRow struct {
	ID              uuid.UUID      `db:"id" json:"id"`
	Email           string         `db:"email" json:"email"`
	Username        string         `db:"username" json:"username"`
	FirstName       sql.NullString `db:"first_name" json:"first_name"`
	LastName        sql.NullString `db:"last_name" json:"last_name"`
	FullName        sql.NullString `db:"full_name" json:"full_name"`
	ProfilePic      sql.NullString `db:"profile_pic" json:"profile_pic"`
	About           sql.NullString `db:"about" json:"about"`
	IsEmailVerified sql.NullBool   `db:"is_email_verified" json:"is_email_verified"`
	IsActive        sql.NullBool   `db:"is_active" json:"is_active"`
	HasAccess       sql.NullBool   `db:"has_access" json:"has_access"`
	LastLoginAt     sql.NullTime   `db:"last_login_at" json:"last_login_at"`
	CreatedAt       sql.NullTime   `db:"created_at" json:"created_at"`
	RoleName        sql.NullString `db:"role_name" json:"role_name"`
	CommunityCount  int64          `db:"community_count" json:"community_count"`
	PostCount       int64          `db:"post_count" json:"post_count"`
	LastActivity    interface{}    `db:"last_activity" json:"last_activity"`
}

func (q *Queries) ListUsers(ctx context.Context, db DBTX, arg ListUsersParams) ([]ListUsersRow, error) {
	rows, err := db.QueryContext(ctx, listUsers, arg.Limit, arg.Offset, arg.Column3)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListUsersRow
	for rows.Next() {
		var i ListUsersRow
		if err := rows.Scan(
			&i.ID,
			&i.Email,
			&i.Username,
			&i.FirstName,
			&i.LastName,
			&i.FullName,
			&i.ProfilePic,
			&i.About,
			&i.IsEmailVerified,
			&i.IsActive,
			&i.HasAccess,
			&i.LastLoginAt,
			&i.CreatedAt,
			&i.RoleName,
			&i.CommunityCount,
			&i.PostCount,
			&i.LastActivity,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchUsers = `-- name: SearchUsers :many
SELECT 
    u.id,
    u.username,
    u.first_name,
    u.last_name,
    u.full_name,
    u.profile_pic,
    u.about,
    u.is_email_verified,
    u.created_at,
    r.name as role_name,
    -- Search relevance score
    CASE 
        WHEN u.username ILIKE $1 THEN 100
        WHEN u.first_name ILIKE $1 THEN 80
        WHEN u.last_name ILIKE $1 THEN 80
        WHEN u.about ILIKE $1 THEN 60
        WHEN u.email ILIKE $1 THEN 40
        ELSE 0
    END as relevance_score
FROM users u
LEFT JOIN roles r ON u.roles_id = r.id
WHERE u.is_active = true
    AND (
        u.username ILIKE $1 
        OR u.first_name ILIKE $1 
        OR u.last_name ILIKE $1 
        OR u.about ILIKE $1 
        OR u.email ILIKE $1
    )
ORDER BY relevance_score DESC, u.created_at DESC
LIMIT $2 OFFSET $3
`

type SearchUsersParams struct {
	Username string `db:"username" json:"username"`
	Limit    int32  `db:"limit" json:"limit"`
	Offset   int32  `db:"offset" json:"offset"`
}

type SearchUsersRow struct {
	ID              uuid.UUID      `db:"id" json:"id"`
	Username        string         `db:"username" json:"username"`
	FirstName       sql.NullString `db:"first_name" json:"first_name"`
	LastName        sql.NullString `db:"last_name" json:"last_name"`
	FullName        sql.NullString `db:"full_name" json:"full_name"`
	ProfilePic      sql.NullString `db:"profile_pic" json:"profile_pic"`
	About           sql.NullString `db:"about" json:"about"`
	IsEmailVerified sql.NullBool   `db:"is_email_verified" json:"is_email_verified"`
	CreatedAt       sql.NullTime   `db:"created_at" json:"created_at"`
	RoleName        sql.NullString `db:"role_name" json:"role_name"`
	RelevanceScore  int32          `db:"relevance_score" json:"relevance_score"`
}

func (q *Queries) SearchUsers(ctx context.Context, db DBTX, arg SearchUsersParams) ([]SearchUsersRow, error) {
	rows, err := db.QueryContext(ctx, searchUsers, arg.Username, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SearchUsersRow
	for rows.Next() {
		var i SearchUsersRow
		if err := rows.Scan(
			&i.ID,
			&i.Username,
			&i.FirstName,
			&i.LastName,
			&i.FullName,
			&i.ProfilePic,
			&i.About,
			&i.IsEmailVerified,
			&i.CreatedAt,
			&i.RoleName,
			&i.RelevanceScore,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
